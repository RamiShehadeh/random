using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;
using DG.Tweening;

namespace Toasts
{
    public enum NotificationCorner { TopRight, TopLeft, BottomRight, BottomLeft }
    public enum NotificationStyle { Info, Success, Warning, Error, Neutral }

    [Serializable]
    public struct NotificationRequest
    {
        public string Title;
        public string Message;
        public Sprite Icon;
        public float? Duration;                 // seconds; null => sticky
        public UnityAction OnClick;             // invoked when toast body clicked
        public NotificationStyle Style;
        public Color? AccentOverride;           // optional color override
        public object Tag;                      // optional correlation token

        public NotificationRequest(string message)
        {
            Title = null;
            Message = message;
            Icon = null;
            Duration = 4f;
            OnClick = null;
            Style = NotificationStyle.Neutral;
            AccentOverride = null;
            Tag = null;
        }
    }

    /// <summary>
    /// Drop this on a GameObject in your scene with a Canvas (Screen Space - Overlay or Camera).
    /// Provide a container RectTransform and a NotificationItem prefab.
    /// </summary>
    public class NotificationManager : MonoBehaviour
    {
        public static NotificationManager Instance { get; private set; }

        [Header("Setup")]
        [SerializeField] private Canvas canvas;                         // optional; auto-find if null
        [SerializeField] private RectTransform container;               // parent for items (uses VerticalLayoutGroup)
        [SerializeField] private NotificationItem itemPrefab;

        [Header("Behavior")]
        [SerializeField] private NotificationCorner corner = NotificationCorner.TopRight;
        [SerializeField] private int maxVisible = 4;
        [SerializeField] private float spacing = 8f;
        [SerializeField] private bool dontDestroyOnLoad = true;
        [SerializeField] private float slidePixels = 32f;               // how far in from edge on enter
        [SerializeField] private float tweenIn = 0.18f;
        [SerializeField] private float tweenOut = 0.15f;

        private readonly Queue<NotificationRequest> _queue = new();
        private readonly List<NotificationItem> _active = new();
        private VerticalLayoutGroup _layout;

        void Awake()
        {
            if (Instance != null && Instance != this)
            {
                Destroy(gameObject);
                return;
            }
            Instance = this;
            if (dontDestroyOnLoad) DontDestroyOnLoad(gameObject);

            if (!canvas) canvas = GetComponentInParent<Canvas>();
            if (!container) container = GetComponentInChildren<RectTransform>(true);
            _layout = container.GetComponent<VerticalLayoutGroup>();
            if (_layout == null) _layout = container.gameObject.AddComponent<VerticalLayoutGroup>();
            _layout.spacing = spacing;
            _layout.childControlHeight = true;
            _layout.childControlWidth = true;
            _layout.childForceExpandHeight = false;
            _layout.childForceExpandWidth = false;

            ApplyCorner();
        }

        void OnValidate()
        {
            if (container)
            {
                var vg = container.GetComponent<VerticalLayoutGroup>();
                if (vg) vg.spacing = spacing;
            }
            ApplyCorner();
        }

        private void ApplyCorner()
        {
            if (!container) return;

            // Anchor/pivot to chosen corner
            Vector2 anchorMin, anchorMax, pivot;
            TextAnchor alignment;
            bool reverse = false;

            switch (corner)
            {
                case NotificationCorner.TopRight:
                    anchorMin = anchorMax = pivot = new Vector2(1, 1);
                    alignment = TextAnchor.UpperRight;
                    reverse = false; // stack downward visually from top (but we use layout; newest at top)
                    break;
                case NotificationCorner.TopLeft:
                    anchorMin = anchorMax = pivot = new Vector2(0, 1);
                    alignment = TextAnchor.UpperLeft;
                    reverse = false;
                    break;
                case NotificationCorner.BottomRight:
                    anchorMin = anchorMax = pivot = new Vector2(1, 0);
                    alignment = TextAnchor.LowerRight;
                    reverse = true;  // visually grow upward
                    break;
                case NotificationCorner.BottomLeft:
                    anchorMin = anchorMax = pivot = new Vector2(0, 0);
                    alignment = TextAnchor.LowerLeft;
                    reverse = true;
                    break;
                default:
                    anchorMin = anchorMax = pivot = new Vector2(1, 1);
                    alignment = TextAnchor.UpperRight;
                    break;
            }

            container.anchorMin = anchorMin;
            container.anchorMax = anchorMax;
            container.pivot = pivot;
            container.anchoredPosition = Vector2.zero;

            if (_layout)
            {
                _layout.childAlignment = alignment;
                // Unity’s VerticalLayoutGroup has no “reverse”, so we just insert at index 0 for top stacks.
            }
        }

        // ---------- Public Static API ----------

        public static void SetCorner(NotificationCorner c) { Ensure().corner = c; Ensure().ApplyCorner(); }
        public static void SetMaxVisible(int n) { Ensure().maxVisible = Mathf.Max(1, n); Ensure().Pump(); }

        public static NotificationItem Show(
            string message,
            Sprite icon = null,
            float? duration = 4f,
            UnityAction onClick = null,
            string title = null,
            NotificationStyle style = NotificationStyle.Neutral,
            Color? accentOverride = null,
            object tag = null)
        {
            var req = new NotificationRequest(message)
            {
                Title = title,
                Icon = icon,
                Duration = duration,
                OnClick = onClick,
                Style = style,
                AccentOverride = accentOverride,
                Tag = tag
            };
            return Show(req);
        }

        public static NotificationItem Show(NotificationRequest req)
        {
            var mgr = Ensure();
            mgr._queue.Enqueue(req);
            mgr.Pump();
            return null; // actual item is created asynchronously in Pump
        }

        public static void DismissAll(bool withAnimation = true)
        {
            var mgr = Ensure();
            // clone to avoid modifying while iterating
            var copy = new List<NotificationItem>(mgr._active);
            foreach (var i in copy) i.Close(withAnimation);
            mgr._queue.Clear();
        }

        // ---------- Internals ----------

        private static NotificationManager Ensure()
        {
            if (Instance != null) return Instance;

            // Create a default system if none exists (convenience).
            var go = new GameObject("NotificationSystem");
            var canvasGO = new GameObject("Canvas", typeof(Canvas), typeof(CanvasScaler), typeof(GraphicRaycaster));
            canvasGO.transform.SetParent(go.transform, false);
            var c = canvasGO.GetComponent<Canvas>();
            c.renderMode = RenderMode.ScreenSpaceOverlay;
            var scaler = canvasGO.GetComponent<CanvasScaler>();
            scaler.uiScaleMode = CanvasScaler.ScaleMode.ScaleWithScreenSize;
            scaler.referenceResolution = new Vector2(1920, 1080);

            var containerGO = new GameObject("Container", typeof(RectTransform), typeof(VerticalLayoutGroup), typeof(ContentSizeFitter));
            containerGO.transform.SetParent(canvasGO.transform, false);
            var rt = containerGO.GetComponent<RectTransform>();
            rt.sizeDelta = new Vector2(420f, 10f);

            var fit = containerGO.GetComponent<ContentSizeFitter>();
            fit.verticalFit = ContentSizeFitter.FitMode.PreferredSize;
            fit.horizontalFit = ContentSizeFitter.FitMode.PreferredSize;

            var mgr = go.AddComponent<NotificationManager>();
            mgr.canvas = c;
            mgr.container = rt;

            Debug.LogWarning("[NotificationManager] No instance in scene. Created a default overlay canvas. For full control, add a NotificationManager prefab to your scene.");
            return mgr;
        }

        private void Pump()
        {
            while (_active.Count < maxVisible && _queue.Count > 0)
            {
                var req = _queue.Dequeue();
                CreateItem(req);
            }
        }

        private void OnItemClosed(NotificationItem item)
        {
            _active.Remove(item);
            Pump();
        }

        private void CreateItem(NotificationRequest req)
        {
            var item = Instantiate(itemPrefab, container);
            // Insert at top for "newest on top" in top corners
            bool newestAtTop = corner == NotificationCorner.TopRight || corner == NotificationCorner.TopLeft;
            if (newestAtTop) item.transform.SetSiblingIndex(0);

            _active.Add(item);

            item.Initialize(
                req,
                slidePixels: slidePixels,
                tweenIn: tweenIn,
                tweenOut: tweenOut,
                // onClosed:
                () => OnItemClosed(item)
            );
        }
    }
}


using System;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;
using UnityEngine.UI;
using TMPro;
using DG.Tweening;

namespace Toasts
{
    /// <summary>
    /// Attach to the NotificationItem prefab. Handles visuals, hover, timers, and tweens.
    /// </summary>
    public class NotificationItem : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler
    {
        [Header("Wiring")]
        [SerializeField] private CanvasGroup rootGroup;
        [SerializeField] private Image backdrop;            // rounded background
        [SerializeField] private Image accentStrip;         // 4px accent strip (optional)
        [SerializeField] private Image iconImage;           // optional icon
        [SerializeField] private TMP_Text titleText;
        [SerializeField] private TMP_Text bodyText;
        [SerializeField] private Button closeButton;        // small × button
        [SerializeField] private CanvasGroup closeCg;       // fade in × on hover
        [SerializeField] private Button bodyButton;         // invisible button covering the body for clicks
        [SerializeField] private LayoutElement layout;      // for min size

        [Header("Style")]
        [SerializeField] private Color bgNeutral = new(0.12f, 0.12f, 0.12f, 0.96f);
        [SerializeField] private Color bgHover = new(0.16f, 0.16f, 0.16f, 0.96f);
        [SerializeField] private Color accentInfo = new(0.28f, 0.58f, 1f, 1f);
        [SerializeField] private Color accentSuccess = new(0.25f, 0.75f, 0.45f, 1f);
        [SerializeField] private Color accentWarning = new(1f, 0.74f, 0.27f, 1f);
        [SerializeField] private Color accentError = new(0.98f, 0.33f, 0.33f, 1f);
        [SerializeField] private Color accentNeutral = new(0.65f, 0.65f, 0.65f, 1f);

        private NotificationRequest _req;
        private float _tweenIn = 0.18f, _tweenOut = 0.15f;
        private float _slide = 24f;
        private bool _hovering;
        private bool _closing;
        private float? _durationRemaining; // countdown (pauses on hover)
        private Tween _fadeTween, _moveTween;

        private Action _onClosed;

        public void Initialize(NotificationRequest req, float slidePixels, float tweenIn, float tweenOut, Action onClosed)
        {
            _req = req;
            _slide = slidePixels;
            _tweenIn = tweenIn;
            _tweenOut = tweenOut;
            _onClosed = onClosed;

            if (!rootGroup) rootGroup = gameObject.AddComponent<CanvasGroup>();
            rootGroup.alpha = 0f;

            // Content
            titleText.gameObject.SetActive(!string.IsNullOrEmpty(req.Title));
            if (titleText) titleText.text = req.Title ?? "";
            if (bodyText) bodyText.text = req.Message ?? "";

            if (iconImage)
            {
                bool showIcon = req.Icon != null;
                iconImage.gameObject.SetActive(showIcon);
                if (showIcon) iconImage.sprite = req.Icon;
            }

            // Accent color by style
            Color accent = req.AccentOverride ?? StyleToColor(req.Style);
            if (accentStrip) accentStrip.color = accent;

            // Close button
            if (closeCg) closeCg.alpha = 0f;
            if (closeButton) closeButton.onClick.AddListener(() => Close(true));

            // Click handler
            if (bodyButton)
            {
                bodyButton.onClick.RemoveAllListeners();
                if (req.OnClick != null)
                    bodyButton.onClick.AddListener(req.OnClick);
                // If you click, macOS usually also dismisses; you can keep or remove this:
                bodyButton.onClick.AddListener(() => Close(true));
            }

            // Timer
            _durationRemaining = req.Duration;

            // Enter animation (fade + slight slide from edge)
            var rt = (RectTransform)transform;
            Vector2 start = rt.anchoredPosition;
            // slide from +X (assumes right corners) or -X (left corners) — infer from parent pivot
            bool rightSide = rt.parent is RectTransform pr && pr.pivot.x > 0.5f;
            float dir = rightSide ? 1f : -1f;

            rt.anchoredPosition = start + new Vector2(_slide * dir, 0f);
            _moveTween = rt.DOAnchorPos(start, _tweenIn).SetEase(Ease.OutCubic);
            _fadeTween = rootGroup.DOFade(1f, _tweenIn).SetEase(Ease.OutQuad);

            if (_durationRemaining.HasValue)
                InvokeRepeating(nameof(Tick), 0.2f, 0.2f);
        }

        private Color StyleToColor(NotificationStyle s) => s switch
        {
            NotificationStyle.Info => accentInfo,
            NotificationStyle.Success => accentSuccess,
            NotificationStyle.Warning => accentWarning,
            NotificationStyle.Error => accentError,
            NotificationStyle.Neutral => accentNeutral,
            _ => accentNeutral
        };

        void OnDestroy()
        {
            _fadeTween?.Kill();
            _moveTween?.Kill();
            CancelInvoke();
        }

        public void Close(bool withAnimation)
        {
            if (_closing) return;
            _closing = true;
            CancelInvoke();

            if (withAnimation && rootGroup)
            {
                var rt = (RectTransform)transform;
                bool rightSide = rt.parent is RectTransform pr && pr.pivot.x > 0.5f;
                float dir = rightSide ? 1f : -1f;

                Sequence seq = DOTween.Sequence();
                seq.Join(rootGroup.DOFade(0f, _tweenOut).SetEase(Ease.InQuad));
                seq.Join(rt.DOAnchorPos(rt.anchoredPosition + new Vector2(_slide * dir, 0f), _tweenOut).SetEase(Ease.InCubic));
                seq.OnComplete(DestroySelf);
            }
            else
            {
                DestroySelf();
            }
        }

        private void DestroySelf()
        {
            try { _onClosed?.Invoke(); } catch { /* user callback safety */ }
            Destroy(gameObject);
        }

        private void Tick()
        {
            if (_hovering || !_durationRemaining.HasValue) return;
            _durationRemaining -= 0.2f;
            if (_durationRemaining <= 0f)
                Close(true);
        }

        // ---------- Hover UX ----------

        public void OnPointerEnter(PointerEventData eventData)
        {
            _hovering = true;
            if (closeCg) closeCg.DOFade(1f, 0.12f).SetEase(Ease.OutQuad);
            if (backdrop) backdrop.DOColor(bgHover, 0.12f);
        }

        public void OnPointerExit(PointerEventData eventData)
        {
            _hovering = false;
            if (closeCg) closeCg.DOFade(0f, 0.16f).SetEase(Ease.InQuad);
            if (backdrop) backdrop.DOColor(bgNeutral, 0.16f);
        }
    }
}




moarrr

using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class UISymbolClusterController : MonoBehaviour
{
    [Header("Refs")]
    [SerializeField] private UISymbolManager symbolManager;
    [SerializeField] private Camera uiCamera;                 // same camera UISymbolManager uses
    [SerializeField] private RectTransform overlayCanvasRoot; // parent for cluster icons (usually symbolContainer)
    
    [Header("Cluster UI")]
    [SerializeField] private GameObject clusterIconPrefab;    // bubble with optional texts (total + per-type row)

    [Header("Tuning")]
    [SerializeField] private int cellPx = 64;
    [SerializeField] private float maxHz = 10f;
    [SerializeField] private float camMovePxThreshold = 24f;
    [SerializeField] private float zoomRelThreshold = 0.03f;  // 3%

    // Internal
    private float _lastRun;
    private Vector3 _lastCamPos;
    private float _lastCamHeight;
    private readonly Dictionary<int, ClusterView> _liveClusters = new();
    private readonly Queue<ClusterView> _pool = new();
    private ScreenGrid _grid;

    // Scratch
    private readonly Dictionary<int, Cell> _cells = new(); // key -> cell data
    private readonly List<UISymbolDisplay> _scratchMembers = new();

    void Reset()
    {
        if (!symbolManager) symbolManager = GetComponent<UISymbolManager>();
    }

    void LateUpdate()
    {
        if (!symbolManager || !uiCamera || !overlayCanvasRoot) return;

        if (!ShouldRecompute()) return;

        // Build/update the math grid when resolution or cellPx changed
        if (_grid.CellPx != cellPx || _grid.Width != Screen.width || _grid.Height != Screen.height)
            _grid = ScreenGrid.Build(cellPx);

        // STEP 1: clear old cell bins
        _cells.Clear();

        // STEP 2: project and bin
        foreach (var kv in symbolManager.SymbolMap)
        {
            var display = kv.Key;
            if (!display || !display.isActiveAndEnabled) continue;

            Vector3 sp = RectTransformUtility.WorldToScreenPoint(uiCamera, display.transform.position);
            if (sp.z <= 0 || sp.x < 0 || sp.y < 0 || sp.x > _grid.Width || sp.y > _grid.Height) 
            {
                display.ClusterHidden = false; // out of view => let UISymbolManager handle hide by its own cull
                continue;
            }

            var cell = _grid.ToCell(new Vector2(sp.x, sp.y));
            int key = cell.y * _grid.Cols + cell.x; // dense, collision-free int key

            if (!_cells.TryGetValue(key, out var c))
            {
                c = new Cell { Key = key, CellCoord = cell };
                _cells[key] = c;
            }

            c.Add(display, kv.Value, new Vector2(sp.x, sp.y));
        }

        // STEP 3: decide who’s hidden and which clusters to show
        // First mark everything as NOT hidden; occupied cells will flip members to hidden if clustered
        foreach (var kv in symbolManager.SymbolMap)
            if (kv.Key) kv.Key.ClusterHidden = false;

        // Track cells used this pass so we can recycle unused cluster views
        var usedClusterKeys = HashSetPool<int>.Get();

        foreach (var kv in _cells)
        {
            var c = kv.Value;

            if (c.Count <= 1)
            {
                // single item -> no cluster bubble, member stays visible
                HideClusterForCell(c.Key); 
                continue;
            }

            // >1: cluster cell
            usedClusterKeys.Add(c.Key);

            // hide all member icons in this cell (cluster replaces them)
            foreach (var m in c.Members)
                if (m) m.ClusterHidden = true;

            // get or spawn one cluster view
            var view = GetClusterForCell(c.Key);
            var center = _grid.CellCenterPx(c.CellCoord);
            view.Rect.anchoredPosition = center;

            // Fill data: total + type breakdown
            view.SetTotal(c.Count);
            view.SetBreakdown(c.TypeCounts);

            view.Show(true);
        }

        // STEP 4: recycle cluster views of cells not used this frame
        var toRecycle = ListPool<int>.Get();
        foreach (var pair in _liveClusters)
            if (!usedClusterKeys.Contains(pair.Key))
                toRecycle.Add(pair.Key);
        foreach (var k in toRecycle) HideClusterForCell(k);
        ListPool<int>.Release(toRecycle);
        HashSetPool<int>.Release(usedClusterKeys);

        // book-keeping
        _lastRun = Time.unscaledTime;
        _lastCamPos = uiCamera.transform.position;
        _lastCamHeight = uiCamera.transform.position.magnitude; // rough zoom proxy
    }

    bool ShouldRecompute()
    {
        if (Time.unscaledTime - _lastRun < 1f / maxHz) return false;

        var cam = uiCamera.transform;
        float camHeight = cam.position.magnitude;
        if (Mathf.Abs(camHeight - _lastCamHeight) / Mathf.Max(1f, _lastCamHeight) > zoomRelThreshold)
            return true;

        if ((cam.position - _lastCamPos).sqrMagnitude > camMovePxThreshold * camMovePxThreshold)
            return true;

        // optionally: return true on a timer if symbols move fast (5–10 Hz is fine)
        return true; // safe default
    }

    // ---------- cluster view pooling ----------
    private ClusterView GetClusterForCell(int key)
    {
        if (_liveClusters.TryGetValue(key, out var v)) return v;

        var go = _pool.Count > 0 ? _pool.Dequeue().gameObject : Instantiate(clusterIconPrefab, overlayCanvasRoot);
        var cv = go.GetComponent<ClusterView>();
        if (!cv) cv = go.AddComponent<ClusterView>();
        cv.Init();
        _liveClusters[key] = cv;
        return cv;
    }

    private void HideClusterForCell(int key)
    {
        if (_liveClusters.TryGetValue(key, out var v))
        {
            v.Show(false);
            _pool.Enqueue(v);
            _liveClusters.Remove(key);
        }
    }

    // ---------- data structs ----------
    private class Cell
    {
        public int Key;
        public Vector2Int CellCoord;
        public readonly List<UISymbolDisplay> Members = new();
        public readonly Dictionary<string, int> TypeCounts = new();
        public int Count => Members.Count;

        public void Add(UISymbolDisplay d, UISymbol symbol, Vector2 screenPos)
        {
            Members.Add(d);
            // get type label from your UISymbol / ScenarioProp / etc.
            string type = symbol != null ? symbol.TypeName : "Unknown"; // add a public TypeName on UISymbol if you don’t have one yet
            if (!TypeCounts.TryGetValue(type, out var c)) c = 0;
            TypeCounts[type] = c + 1;
        }
    }

    // math grid
    private struct ScreenGrid
    {
        public int CellPx, Cols, Rows, Width, Height;

        public static ScreenGrid Build(int cellPx)
        {
            var g = new ScreenGrid
            {
                CellPx = cellPx,
                Width = Screen.width,
                Height = Screen.height
            };
            g.Cols = Mathf.CeilToInt((float)g.Width / cellPx);
            g.Rows = Mathf.CeilToInt((float)g.Height / cellPx);
            return g;
        }

        public Vector2Int ToCell(Vector2 screenPos)
        {
            return new Vector2Int(
                Mathf.Clamp((int)(screenPos.x / CellPx), 0, Cols - 1),
                Mathf.Clamp((int)(screenPos.y / CellPx), 0, Rows - 1)
            );
        }

        public Vector2 CellCenterPx(Vector2Int cell)
        {
            return new Vector2(cell.x * CellPx + CellPx * 0.5f,
                               cell.y * CellPx + CellPx * 0.5f);
        }
    }

    // ---------- light pools ----------
    static class ListPool<T>
    {
        static readonly Stack<List<T>> pool = new();
        public static List<T> Get() => pool.Count > 0 ? pool.Pop() : new List<T>(64);
        public static void Release(List<T> l) { l.Clear(); pool.Push(l); }
    }

    static class HashSetPool<T>
    {
        static readonly Stack<HashSet<T>> pool = new();
        public static HashSet<T> Get() => pool.Count > 0 ? pool.Pop() : new HashSet<T>();
        public static void Release(HashSet<T> s) { s.Clear(); pool.Push(s); }
    }
}

// Simple view wrapper so we don’t depend on a specific prefab structure
public class ClusterView : MonoBehaviour
{
    public RectTransform Rect { get; private set; }
    [SerializeField] private TMP_Text totalText;      // optional
    [SerializeField] private Transform breakdownRoot; // optional parent for per-type rows

    public void Init()
    {
        if (!Rect) Rect = transform as RectTransform;
        // Try auto-wire children by name if not set in Inspector
        if (!totalText) totalText = transform.GetComponentInChildren<TMP_Text>();
    }

    public void SetTotal(int total)
    {
        if (totalText) totalText.text = total > 99 ? "99+" : total.ToString();
    }

    public void SetBreakdown(Dictionary<string, int> typeCounts)
    {
        // Optional: populate colored chips under the total
        // (left for your specific prefab; safe to no-op)
    }

    public void Show(bool v) => gameObject.SetActive(v);
}



